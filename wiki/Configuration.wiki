#summary Describes Obfuscar configuration xml
#labels Featured

= Obfuscar Configuration =

Obfuscar accepts a single command line argument, the path to its configuration file.

The configuration file is used to specify what assemblies should be obfuscated, where to find the dependencies for the assemblies, and where the obfuscated assemblies should be saved.

== Variables, `InPath` and `OutPath` ==

The following is a is an example of a minimal configuration.  It is provided in the release as part of the BasicExample:
{{{
<?xml version='1.0'?>
<Obfuscator>
  <Var name="InPath" value=".\Obfuscator_Input" />
  <Var name="OutPath" value=".\Obfuscator_Output" />

  <Module file="$(InPath)\BasicExampleExe.exe" />
  <Module file="$(InPath)\BasicExampleLibrary.dll" />
</Obfuscator>
}}}

In the example configuration, two variables are defined, `InPath` and `OutPath`, using the `Var` element, and two assemblies are listed for obfuscation, an executable and a dll.

Variables defined using the `Var` element will be expanded in strings following the definition...After defining `InPath` as follows:
{{{
  <Var name="InPath" value=".\Obfuscator_Input" />
}}}

It can be used in another location:
{{{
  <Module file="$(InPath)\BasicExampleExe.exe" />
}}}

In addition to being usable like macros, there are a few special variables that have additional effects.  The variable `InPath` is used when trying to find dependencies (the specified path is searched), and the variable `OutPath` is used as the output path for the obfuscated assemblies and the map.  If either `InPath` or `OutPath` is unspecified, they default to the current path (".").

== Modules ==

For each assembly to be obfuscated, there must be a `Module` element.  Assemblies referenced by an assembly specified by a `Module` element must be resolveable, either via Cecil's regular resolve process, or they must be present in the path specified by `InPath`.

Though additional assemblies are loaded for examination, only the specified assemblies will be obfuscated.

== Exclusion by Configuration ==

It is possible to include additional elements within the `Module` elements to skip types (the `SkipTypes` element), methods (the `SkipMethod` element), fields (`SkipField`), properties (`SkipProperty`), and events (`SkipEvent`, of course).

The `SkipNamespace` element specifies a namespace that should be skipped.  All types, methods, fields, etc., within the namespace will be skipped.

The `SkipType` element specifies the name of the type to skip, including the full namespace.  It can also specify whether to skip the method, fields, properties, and/or events within the type.

The `SkipMethod` element specifies the name of the type containing the method, a protection specifier, and a name or regex to match the method.  The protection specifier is currently ignored, but will eventually be used for additional filtering.

The `SkipField` element specifies the name of the type containing the field, a protection specifier, and a name or regex to match the field.  The protection specifier is currently ignored, but will eventually be used for additional filtering.

The `SkipProperty` element specifies the name of the type containing the property, a protection specifier, and a name or regex to match the property.  The protection specifier is currently ignored, but will eventually be used for additional filtering.

The `SkipEvent` element specifies the name of the type containing the event, a protection specifier, and a name or regex to match the event.  The protection specifier is currently ignored, but will eventually be used for additional filtering.

A more complete example:
{{{
  <Module file="$(InPath)\AssemblyX.exe">
    <!-- skip a namespace -->
    <SkipNamespace name="Company.PublicBits" />

    <!-- to skip a namespace recursively, just put * on the end -->
    <SkipNamespace name="Company.PublicBits*" />

    <!-- skip field by name -->
    <SkipField type="Full.Namespace.And.TypeName"
      attrib="public" name="Fieldname" />

    <!-- skip field by regex -->
    <SkipField type="Full.Namespace.And.TypeName"
      attrib="public" rx="Pub.*" />

    <!-- skip type...will still obfuscate its methods -->
    <SkipType name="Full.Namespace.And.TypeName2" />

    <!-- skip type...will skip its methods next -->
    <SkipType name="Full.Namespace.And.TypeName3" />
    <!-- skip TypeName3's public methods -->
    <SkipMethod type="Full.Namespace.And.TypeName3"
      attrib="public" rx=".*" />
    <!-- skip TypeName3's protected methods -->
    <SkipMethod type="Full.Namespace.And.TypeName3"
      attrib="family" rx=".*" />

    <!-- skip type and its methods -->
    <SkipType name="Full.Namespace.And.TypeName4" skipMethods="true" />
    <!-- skip type and its fields -->
    <SkipType name="Full.Namespace.And.TypeName4" skipFields="true" />
    <!-- skip type and its properties -->
    <SkipType name="Full.Namespace.And.TypeName4" skipProperties="true" />
    <!-- skip type and its events -->
    <SkipType name="Full.Namespace.And.TypeName4" skipEvents="true" />
    <!-- skip attributes can be combined (this will skip the methods and fields) -->
    <SkipType name="Full.Namespace.And.TypeName4" skipMethods="true" skipFields="true" />

    <!-- skip a property in TypeName5 by name -->
    <SkipProperty type="Full.Namespace.And.TypeName5"
      name="Property2" />
    <!-- skip a property in TypeName5 by regex -->
    <SkipProperty type="Full.Namespace.And.TypeName5"
      attrib="public" rx="Something\d" />

    <!-- skip an event in TypeName5 by name -->
    <SkipProperty type="Full.Namespace.And.TypeName5"
      name="Event2" />
    <!-- skip an event in TypeName5 by regex -->
    <SkipProperty type="Full.Namespace.And.TypeName5"
      rx="Any.*" />
  </Module>
}}}

To prevent all properties from being obfuscated, set the `RenameProperties` variable to "false" (it's an xsd boolean).  To prevent specific properties from being renamed, use the `SkipProperty` element.  It will also skip the property's accessors, `get_XXX` and `set_XXX`.

To prevent all events from being obfuscated, set the `RenameEvents` variable to "false" (it's also xsd boolean).  To prevent specific events from being renamed, use the `SkipEvent` element.  It will also skip the event's accessors, `add_XXX` and `remove_XXX`.

=== Name Matching ===

The `SkipMethod`, `SkipProperty`, `SkipEvent`, and `SkipField` elements all accept an `rx` attribute that specifies a regular expression used to match the name of the thing to be skipped.  The `SkipType`, `SkipMethod`, `SkipProperty`, `SkipEvent`, and `SkipField` elements all accept a `name` attribute that specifies a string or regular expression used to match the name of the thing to be skipped.

For elements where both the `name` and `rx` attributes can be specified, if both are specified, the `rx` attribute will be ignored.

The `name` attribute can specify either a string or regular expression to match the name of the thing to be skipped.  If the value of the `name` attribute begins with a '`^`' character, the value (including the '`^`') will be treated as a regular expression (e.g., the name '`^so.*g`' will match the string `something`).  Otherwise, the value will be used as a wildcard string, where '`*`' matches zero or more characters, and '`?`' matches a single character (e.g., the wildcard string `som?t*g` will match the string `something`).

This behavior also applies to the value of the `type` attribute of the `SkipMethod`, `SkipProperty`, `SkipEvent`, and `SkipField` elements.

== Exclusion by Code ==

There's also some functionality where you can mark types with an attribute to prevent them from being obfuscated...reference Obfuscar.exe and add the `Obfuscate` attribute to your types.  For example, to suppress obfuscation of `X`, its methods, fields, resources, etc.:
{{{
  [Obfuscate( false )]
  class X { }
}}}

The `Obfuscate` attribute has a flag, `ShouldObfuscate`, that defaults to true if not set.  The following are equivalent:
{{{
  [Obfuscate]
  class X { }

  [Obfuscate( true )]
  class Y { }

  [Obfuscate( ShouldObfuscate = true )]
  class X { }
}}}

And if you only want specific classes obfuscated, you can set the `MarkedOnly` variable to "true" (also an xsd boolean), and apply the `Obfuscate` attribute to the things you want obfuscated.  This is done in the !ObfuscarTests project (included w/ the source...it's intended to be a place for unit tests, but for now does little) to obfuscate a subset of the classes.  For example, if `MarkedOnly` is set to true, to include obfuscation of `X`, its methods, fields, resources, etc.:
{{{
  [Obfuscate]
  class X { }
}}}
